# CSP.py
import os, sys

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import hashlib
from typing import List, Dict, Optional
from utils.ImprovedPaillier import ImprovedPaillier
from utils.Threshold import recover_secret
from utils.SafeMul import SafeInnerProduct


class CSP:
    """ä¸­å¿ƒæœåŠ¡å™¨ï¼ˆCSPï¼?""

    def __init__(self, ta, model_size: int = 5, precision: int = 10 ** 6):
        self.ta = ta
        self.model_size = model_size
        self.precision = precision

        # å…¨å±€æ¨¡å‹å‚æ•°ç®¡ç†
        self.global_params: List[float] = [0.0] * self.model_size
        self.global_params_snapshot: List[float] = list(self.global_params)
        self.round_count: int = 0

        # ä¸ºæ‰çº¿æ¢å¤ç¼“å­?
        self.recoveredNiValues: Dict[int, int] = {}

        # ä¿å­˜TAç”Ÿæˆçš„æ­£äº¤å‘é‡ç»„
        self.orthogonal_vectors_for_csp: List[List[float]] = []
        self._load_orthogonal_vectors()

        # ä½¿ç”¨ ImprovedPaillierï¼Œä½†ç”?TA çš„å‚æ•°è¦†ç›–ï¼Œç¡®ä¿å…¨å±€ä¸€è‡?
        self.impaillier = ImprovedPaillier(m=self.ta.num_do, bit_length=512, precision=self.precision)
        self._sync_paillier_with_ta()

    def _load_orthogonal_vectors(self) -> None:
        self.orthogonal_vectors_for_csp = self.ta.get_orthogonal_vectors_for_csp()
        print(f"[CSP] å·²åŠ è½½æ­£äº¤å‘é‡ç»„ï¼Œå…±{len(self.orthogonal_vectors_for_csp)}ä¸ªå‘é‡?)

    def _sync_paillier_with_ta(self) -> None:
        """åŒæ­¥å…¬å‚ï¼ŒåŒ…æ‹?y å‚æ•°"""
        N = self.ta.get_N()
        self.impaillier.N = N
        self.impaillier.N2 = N * N
        self.impaillier.g = self.ta.get_g()
        self.impaillier.h = self.ta.get_h()
        
        # åŒæ­¥ lambda_ å’?u å‚æ•°
        try:
            self.impaillier.lambda_ = self.ta.get_lambda()
        except Exception:
            self.impaillier.lambda_ = getattr(self.ta, 'lambda_val', None)
        
        if hasattr(self.ta, 'u'):
            self.impaillier.u = self.ta.u
        elif hasattr(self.ta, 'mu'):
            self.impaillier.u = self.ta.mu
            
        # **é‡è¦ï¼šåŒæ­?y å‚æ•°ï¼Œç¡®ä¿è§£å¯†ä¸€è‡´æ€?*
        try:
            self.impaillier.y = self.ta.get_y()
        except Exception:
            self.impaillier.y = getattr(self.ta, 'gamma', None)
            
        print(f"[CSP] å·²åŒæ­¥Paillierå…¬å‚ï¼ŒN={N}, g={self.impaillier.g}, h={self.impaillier.h}, y={self.impaillier.y}")
    # ============== å¹¿æ’­ ==============
    def broadcast_params(self) -> List[float]:
        try:
            self.ta.update_keys_for_new_round()
        except Exception as e:
            print(f"[CSP] å¯†é’¥æ›´æ–°å¤±è´¥: {e}")
        self.global_params_snapshot = list(self.global_params)
        self.round_count += 1
        print(f"[CSP] ç¬¬{self.round_count}è½®å¹¿æ’­å‚æ•? {self.global_params_snapshot}")
        return list(self.global_params_snapshot)

    # ============== æ”¶é›†/èšåˆ ==============
    def aggregate_ciphertexts(self, do_cipher_map: Dict[int, List[int]]) -> List[int]:
        """é€åæ ‡åŒæ€èšåˆï¼šä½¿ç”¨ImprovedPaillierçš„èšåˆæ–¹æ³?""
        aggregated: List[int] = []

        for i in range(self.model_size):
            coordinate_ciphertexts = []
            for do_id, c_vec in do_cipher_map.items():
                if c_vec is not None and i < len(c_vec):
                    coordinate_ciphertexts.append(c_vec[i])

            if coordinate_ciphertexts:
                aggregated_cipher = self.impaillier.aggregate(coordinate_ciphertexts)
                aggregated.append(aggregated_cipher)
            else:
                # åŠ å¯†0ä½œä¸ºå ä½ï¼ˆä½¿ç”?SK_DO = 1 å³ä¸ä¼šå½±å“ä¹˜ç§¯ï¼‰
                zero_cipher = self.impaillier.encrypt(0.0, 1)
                aggregated.append(zero_cipher)

        print(f"[CSP] èšåˆå®Œæˆï¼Œå…±{len(aggregated)}ä¸ªåæ ?)
        return aggregated

    # ============== æ‰çº¿æ¢å¤ ==============
    # åŸºäºé—¨é™æ¢å¤ç¼ºå¤± n_iï¼ˆä»åœ¨çº¿ DO æ”¶é›†åˆ†ç‰‡å¹¶é‡æ„ï¼‰
    def recover_missing_private_keys(self, missing_ids: List[int], online_dos: List, threshold: int) -> Dict[int, int]:
        self.recoveredNiValues.clear()
        print(f"[CSP] æ£€æµ‹åˆ°æ‰çº¿ DO: {missing_ids}ï¼Œåœ¨çº¿DO: {[d.id for d in online_dos]}")

        for missing_id in missing_ids:
            try:
                shares_map: Dict[int, int] = {}
                prime_used: Optional[int] = None

                for do in online_dos:
                    info = None
                    try:
                        info = do.get_key_share_info(missing_id)
                    except Exception:
                        info = None

                    if info is None:
                        continue

                    share_val = info.get('share')
                    prime = info.get('prime')
                    do_id = info.get('do_id')

                    if share_val is None or prime is None or do_id is None:
                        continue

                    if prime_used is None:
                        prime_used = prime
                    elif prime_used != prime:
                        print(f"[CSP] åˆ†ç‰‡ç´ æ•°ä¸ä¸€è‡´ï¼Œå¿½ç•¥DO {do_id} çš„åˆ†ç‰?)
                        continue

                    # æ³¨æ„ shares çš?x å–åœ¨çº?DO çš„ç¼–å?+ 1ï¼ˆä¸ç”Ÿæˆæ—¶ä¸€è‡´ï¼‰
                    shares_map[do_id + 1] = share_val

                    if len(shares_map) >= threshold:
                        break

                if len(shares_map) < threshold or prime_used is None:
                    print(f"[CSP] æ¢å¤DO {missing_id} åˆ†ç‰‡ä¸è¶³ï¼š{len(shares_map)}/{threshold}")
                    continue

                recovered_n = recover_secret(shares_map, prime_used)
                self.recoveredNiValues[missing_id] = recovered_n
                print(f"[CSP] æˆåŠŸæ¢å¤DO {missing_id} çš?n_i{recovered_n}")

            except Exception as e:
                print(f"[CSP] æ¢å¤DO {missing_id} æ—¶å‡ºé”? {e}")

        return self.recoveredNiValues

    # ============== è§£å¯†æµç¨‹ï¼ˆæ­£å¸?å¸¦æ¢å¤ï¼‰ ==============
    def _decrypt_vector(self, aggregated: List[int]) -> List[float]:
        results: List[float] = [0.0] * self.model_size
        for i in range(self.model_size):
            results[i] = self.impaillier.decrypt(aggregated[i])
        print(f"[CSP] æ­£å¸¸è§£å¯†ç»“æœ: {results}")
        return results

    def _decrypt_with_recovery(self, aggregated: List[int], params_hash: int) -> List[float]:
       
        """æ¢å¤ç¼ºå¤± n_i åè§£å¯†ï¼ˆä¿æŒåŸé€»è¾‘ï¼?""
        N2 = self.impaillier.N2
        N = self.impaillier.N

        # æ±‚å’Œ n_iï¼ˆç”± TA æ¢å¤å¹¶å­˜å…?self.recoveredNiValuesï¼?
        sumNi = sum(self.recoveredNiValues.values())
        sumNi = (sumNi * params_hash) % N  # é¿å…æº¢å‡º

        R_t = self.ta.get_R_t()
        Rt_pow = pow(R_t, sumNi, N2)

        results: List[float] = [0.0] * self.model_size
        for i in range(self.model_size):
            modified = (aggregated[i] * Rt_pow) % N2
            results[i] = self.impaillier.decrypt(modified)
            print(f"[CSP] æ¢å¤è§£å¯†åæ ‡ {i}: åŸå§‹å¯†æ–‡={aggregated[i]}, ä¿®æ­£å¯†æ–‡={modified} -> æ˜æ–‡={results[i]}")
        return results

    # ============== ä¸»æµç¨?==============
    def round_aggregate_and_update(self, do_list: List[Optional[object]], do_cipher_map: Dict[int, List[int]]) -> List[
        float]:
        print(f"[CSP] å¼€å§‹ç¬¬{self.round_count}è½®èšåˆå’Œæ›´æ–°")
        aggregated = self.aggregate_ciphertexts(do_cipher_map)

        online_dos = [d for d in do_list if d is not None]
        missing_ids = [idx for idx, d in enumerate(do_list) if d is None]
        print(f"[CSP] åœ¨çº¿DO: {[d.id for d in online_dos]}, æ‰çº¿DO: {missing_ids}")
            # è®¡ç®—å½“å‰å…¨å±€å‚æ•°å“ˆå¸Œï¼Œå¦‚æœæœ‰DOæ‰çº¿äº†ï¼Œéœ€è¦ä½¿ç”?
        params_bytes = str(self.global_params_snapshot).encode('utf-8')
        params_hash = int.from_bytes(hashlib.sha256(params_bytes).digest(), 'big', signed=False)

        if not missing_ids:
            summed = self._decrypt_vector(aggregated)
        else:
            print(f"\n\n[CSP] æ£€æµ‹åˆ°æ‰çº¿DOï¼Œè¿›è¡Œå¯†é’¥æ¢å¤\n")
            self.recover_missing_private_keys(missing_ids, online_dos, self.ta.get_threshold())
            summed = self._decrypt_with_recovery(aggregated, params_hash)

        print(f"[CSP] è§£å¯†åçš„èšåˆç»“æœ: {summed}")

        num_online = max(1, len(online_dos))
        next_params = [
            self.global_params_snapshot[i] + (summed[i] / num_online)
            for i in range(self.model_size)
        ]

        self.global_params = next_params
        print(f"[CSP] æ›´æ–°åçš„å…¨å±€å‚æ•°: {next_params}")

        return next_params

    # ============== SafeMul: 1+3è½®ï¼ˆPAä¾§ï¼‰ ==============
    def safe_mul_prepare_payload(self) -> Dict[str, object]:
        """å‡†å¤‡å®‰å…¨ç‚¹ç§¯ç¬?è½®æ•°æ®ï¼ŒåŸºäº CSP çš„æ­£äº¤å‘é‡ç»„å‘é€?(p, alpha, C_all)ã€?""
        sip = SafeInnerProduct(precision_factor=self.precision)
        p, alpha, C_all, s, s_inv = sip.round1_setup_and_encrypt(self.orthogonal_vectors_for_csp)
        return {'p': p, 'alpha': alpha, 'C_all': C_all, 's_inv': s_inv}

    def safe_mul_finalize(self, ctx: Dict[str, object], D_sums: List[int], do_part: List[float]) -> List[float]:
        """æ‰§è¡Œå®‰å…¨ç‚¹ç§¯ç¬?è½®å¹¶ä¸?DO æ˜æ–‡éƒ¨åˆ†æ±‚å’Œï¼Œå¾—åˆ?wÂ·U çš?1Ã—m å‘é‡ã€?""
        sip = SafeInnerProduct(precision_factor=self.precision)
        p = ctx['p']
        alpha = ctx['alpha']
        s_inv = ctx['s_inv']
        csp_part = sip.round3_decrypt(D_sums, s_inv, alpha, p)
        return [csp_part[i] + do_part[i] for i in range(len(csp_part))]
# ===========================
# === æµ‹è¯•ä»£ç éƒ¨åˆ† (CSP.py) ===
# ===========================
if __name__ == "__main__":
    print("===== [TEST] å¯åŠ¨ CSP æµ‹è¯• =====")
    from TA.TA import TA
    from DO.DO import DO

    # åˆå§‹åŒ?
    ta = TA(num_do=3, model_size=5, orthogonal_vector_count=3, bit_length=512)
    csp = CSP(ta)
    do_list = [DO(i, ta) for i in range(3)]

    print("\n===== Round 1: å¹¿æ’­å‚æ•° =====")
    global_params = csp.broadcast_params()

    print("\n===== Round 1: æ”¶é›†å?DO çš„å¯†æ–‡æ›´æ–?=====")
    do_cipher_map = {}
    for do in do_list:
        ciphertexts = do.train_and_encrypt(global_params)
        do_cipher_map[do.id] = ciphertexts

    print("\n===== Round 1: CSP èšåˆ + è§£å¯†æ›´æ–° =====")
    new_params = csp.round_aggregate_and_update(do_list, do_cipher_map)
    print(f"\n>>> Round 1 ç»“æŸï¼Œæ–°å…¨å±€å‚æ•°: {new_params}")

    print("\n===== Round 2: æ¨¡æ‹Ÿ DO2 æ‰çº¿å¹¶æ¢å¤?=====")
    global_params = csp.broadcast_params()
    do_list[2] = None  # æ¨¡æ‹Ÿæ‰çº¿

    do_cipher_map = {}
    for do in [d for d in do_list if d is not None]:
        ciphertexts = do.train_and_encrypt(global_params)
        do_cipher_map[do.id] = ciphertexts

    new_params = csp.round_aggregate_and_update(do_list, do_cipher_map)
    print(f"\n>>> Round 2 ç»“æŸï¼ˆå«æ¢å¤ï¼‰ï¼Œæ–°å…¨å±€å‚æ•°: {new_params}")

    print("\n===== æµ‹è¯•å®Œæˆ =====")
